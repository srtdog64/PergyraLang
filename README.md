# Pergyra 프로그래밍 언어

> **"메모리를 슬롯으로, 실행을 의도로"** - 차세대 시스템 프로그래밍 언어

## 🚀 프로젝트 개요

Pergyra는 포인터 대신 **슬롯 기반 메모리 관리**를 채택한 혁신적인 시스템 프로그래밍 언어입니다. 메모리 안전성과 병렬 처리를 언어 차원에서 지원하며, 어셈블리 최적화와 JVM 연동을 통해 고성능을 제공합니다.

## ✨ 핵심 특징

### 🔒 **슬롯 기반 메모리 관리**
- **포인터 없음**: 주소 대신 타입 안전한 슬롯 참조
- **자동 생명주기**: 스코프 기반 TTL로 메모리 누수 방지
- **원자적 접근**: 동시성 환경에서 안전한 메모리 접근

```pergyra
with slot<Int> as s {
    s.write(42)
    log(s.read())
} // 자동 해제
```

### ⚡ **내장 병렬성**
- **문법 차원 병렬**: `parallel` 블록으로 간단한 병렬 처리
- **스레드 안전**: 슬롯 시스템이 보장하는 데이터 레이스 방지

```pergyra
let result = parallel {
    process_a()
    process_b() 
    process_c()
}
```

### 🔧 **하이브리드 구현**
- **어셈블리 최적화**: 핵심 성능 루틴은 x86-64 어셈블리로 구현
- **JVM 연동**: JNI를 통한 Java 생태계 활용
- **C 호환성**: 기존 C 라이브러리와의 원활한 연동

## 📁 프로젝트 구조

```
PergyraLang/
├── src/
│   ├── lexer/           # 토크나이저 (어셈블리 최적화)
│   │   ├── lexer.h
│   │   └── lexer.c
│   ├── parser/          # AST 생성기
│   │   ├── ast.h
│   │   └── parser.h
│   ├── runtime/         # 슬롯 매니저 (어셈블리 + C)
│   │   ├── slot_manager.h
│   │   ├── slot_manager.c
│   │   └── slot_asm.s   # 어셈블리 최적화 루틴
│   ├── jvm_bridge/      # JVM 연동 계층
│   │   └── jni_bridge.h
│   ├── semantic/        # 의미 분석
│   ├── codegen/         # 코드 생성
│   └── main.c          # 테스트 드라이버
├── docs/               # 문서
│   └── grammar.md      # 언어 문법 정의
├── tests/              # 테스트 코드
├── examples/           # 예제 코드
├── tools/             # 개발 도구
└── Makefile           # 빌드 시스템
```

## 🛠️ 빌드 방법

### 필요 조건
- GCC 7.0+ (C11 지원)
- NASM (어셈블리)
- GNU Make
- JDK 8+ (JVM 연동용)

### 빌드 명령어

```bash
# 전체 빌드
make all

# 렉서만 테스트
make lexer_test

# 테스트 실행
make test

# 디버그 빌드
make debug

# 릴리즈 빌드
make release

# 정리
make clean
```

## 🧪 현재 구현 상태

### ✅ 완료된 컴포넌트
- **토크나이저**: 완전한 Pergyra 토큰 분석
- **AST 구조**: 언어 구문의 추상 구문 트리 정의
- **슬롯 매니저**: 어셈블리 최적화된 메모리 관리
- **JNI 브릿지**: JVM 연동을 위한 인터페이스

### 🚧 개발 중인 컴포넌트
- **파서**: AST 생성 로직
- **의미 분석**: 타입 검사 및 스코프 분석
- **코드 생성**: 중간 코드 생성

### 📋 계획된 기능
- **LLVM 백엔드**: 다중 플랫폼 지원
- **웹어셈블리 타겟**: 브라우저 실행 지원
- **패키지 매니저**: 모듈 시스템

## 🎯 언어 철학

### 1. **의미 기반 선언**
모든 코드는 의도를 명확히 표현해야 합니다.

### 2. **슬롯 기반 소유권**
메모리는 주소가 아닌 역할 단위로 관리됩니다.

### 3. **선언적 병렬성**
멀티스레드 실행은 문법 차원에서 선언됩니다.

### 4. **의도-구조-실행 사이클**
- 프로그래머가 **의도**를 작성
- 컴파일러가 **구조**를 분석  
- 런타임이 **최적 실행**을 생성

## 📖 기본 문법 예제

```pergyra
// 슬롯 기반 메모리 관리
let slot = claim_slot<Int>()
write(slot, 42)
let value = read(slot)
release(slot)

// 스코프 기반 자동 관리
with slot<String> as s {
    s.write("Hello, Pergyra!")
    log(s.read())
}

// 병렬 처리
let results = parallel {
    calculate_prime(1000)
    sort_array(data)
    compress_file(input)
}
```

## 🔬 성능 특징

- **Zero-copy 슬롯 접근**: 어셈블리 최적화로 포인터 수준의 성능
- **락-프리 동시성**: Compare-and-Swap 기반 원자적 연산
- **캐시 친화적**: 연속 메모리 할당으로 캐시 미스 최소화
- **NUMA 인식**: 멀티소켓 시스템에서 로컬 메모리 우선 사용

## 🤝 기여 방법

1. **이슈 리포팅**: 버그나 개선사항을 GitHub Issues에 등록
2. **코드 기여**: Pull Request를 통한 코드 개선
3. **문서화**: 언어 문법이나 API 문서 작성
4. **테스트**: 다양한 환경에서의 테스트 진행

## 📄 라이센스

이 프로젝트는 [MIT 라이센스](LICENSE) 하에 배포됩니다.

## 📞 연락처

- **개발자**: [개발자명]
- **이메일**: [이메일 주소]
- **GitHub**: [GitHub 저장소]

---

> **"Pergyra로 메모리 안전하고 병렬 친화적인 시스템을 구축하세요"**