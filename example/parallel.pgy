/*
 * Copyright (c) 2025 Pergyra Language Project
 * All rights reserved.
 *
 * This example demonstrates advanced parallel processing features
 * including multithreaded matrix multiplication.
 *
 * Licensed under BSD 3-Clause License.
 */

// Pergyra 병렬 처리 고급 예제
// 멀티스레드 행렬 곱셈

// 행렬 데이터 타입 정의
type Matrix = {
    rows: Int,
    cols: Int,
    data: Array<Float>
}

// 행렬 생성 함수
func CreateMatrix(rows: Int, cols: Int) -> Matrix {
    with slot<Matrix> as matrix {
        matrix.Write(Matrix {
            rows: rows,
            cols: cols,
            data: CreateArray(rows * cols)
        })
        
        return matrix.Read()
    }
}

// 병렬 행렬 곱셈
func ParallelMatrixMultiply(a: Matrix, b: Matrix) -> Matrix {
    if a.cols != b.rows {
        Panic("행렬 차원이 맞지 않습니다")
    }
    
    let result = CreateMatrix(a.rows, b.cols)
    
    // 각 행을 병렬로 처리
    Parallel {
        for rowIdx in 0..a.rows {
            CalculateRow(a, b, result, rowIdx)
        }
    }
    
    return result
}

// 단일 행 계산 (병렬 작업 단위)
func CalculateRow(a: Matrix, b: Matrix, result: Matrix, row: Int) {
    with slot<Float> as sum {
        for col in 0..b.cols {
            sum.Write(0.0)
            
            for k in 0..a.cols {
                let aVal = a.data[row * a.cols + k]
                let bVal = b.data[k * b.cols + col]
                let currentSum = sum.Read()
                sum.Write(currentSum + aVal * bVal)
            }
            
            result.data[row * result.cols + col] = sum.Read()
        }
    }
}

// 스레드 풀 기반 병렬 처리
func ThreadedComputation() {
    let threadCount = GetCpuCount()
    
    with slot<Array<Int>> as results {
        results.Write(CreateArray(threadCount))
        
        Parallel {
            for threadId in 0..threadCount {
                WorkerThread(threadId, results)
            }
        }
        
        // 결과 집계
        with slot<Int> as total {
            total.Write(0)
            
            for result in results.Read() {
                total.Write(total.Read() + result)
            }
            
            Log("총 합계:", total.Read())
        }
    }
}

// 워커 스레드 함수
func WorkerThread(id: Int, sharedResults: slot<Array<Int>>) {
    with slot<Int> as localSum {
        localSum.Write(0)
        
        // 각 스레드별 작업 범위 계산
        let workSize = 1000 / GetCpuCount()
        let start = id * workSize
        let end = start + workSize
        
        for i in start..end {
            localSum.Write(localSum.Read() + ComputeExpensive(i))
        }
        
        // 결과를 공유 배열에 저장
        sharedResults.Read()[id] = localSum.Read()
    }
}

// 비용이 많이 드는 계산 (예시)
func ComputeExpensive(n: Int) -> Int {
    with slot<Int> as result {
        result.Write(1)
        
        for i in 1..n {
            result.Write(result.Read() * 2)
            result.Write(result.Read() % 1000000)  // 오버플로우 방지
        }
        
        return result.Read()
    }
}

// 메인 실행
func Main() {
    Log("=== Pergyra 병렬 처리 데모 ===")
    
    // 행렬 곱셈 테스트
    let matrixA = CreateMatrix(100, 100)
    let matrixB = CreateMatrix(100, 100)
    
    // 행렬 초기화
    InitializeRandomMatrix(matrixA)
    InitializeRandomMatrix(matrixB)
    
    Log("행렬 곱셈 시작...")
    let startTime = GetTime()
    
    let resultMatrix = ParallelMatrixMultiply(matrixA, matrixB)
    
    let endTime = GetTime()
    Log("행렬 곱셈 완료 (", endTime - startTime, "ms)")
    
    // 스레드 풀 테스트
    Log("스레드 풀 테스트 시작...")
    ThreadedComputation()
    
    Log("모든 테스트 완료!")
}